/*exported mGenGenerate */

var mGenJsonHandler = function(builder) {
    "use strict";
    this.builder = builder;
};

mGenJsonHandler.prototype.createObjectFromJSONString = function(data) {
    "use strict";
    if (typeof data !== "string") throw "Create from string needs a string argument";
    var object = JSON.parse(data);
    return this.createObjectFromJSON(object);
};

mGenJsonHandler.prototype.createObjectFromJSON = function(object) {
    "use strict";
    return new(this.builder.getClassWithId(object.__t))(object);
};

mGenJsonHandler.prototype.toJSONString = function(object) {
    "use strict";
    return JSON.stringify(object);
};


/**
 *
 * MGEN BUILDER GENERATOR.
 *
 * This module is used to create a mgen-builder. The builder is
 * later used to instanciate classes. To create a builder simply
 * call mGenGenerate with a registry (generated by mgen-javascriptgenerator)
 *
 * @param {object} registry - registry object created by mgen-javascriptgenerator (REQUIRED).
 *
 * @param settings {object} Settings for adjusting the behavior on creation of objects (OPTIONAL).
 * @param settings.warn              {bool} Set to true if warnings should be printed in console, default is true
 * @param settings.never_catch_error {bool} Set to true if mgen never internally should catch error, this is preferable when you want to find the origin of a error instead of a pritty error. Default false
 * @param settings.validate          {bool} Set to true for type-validation of data on creation. There is a fairly big performace improvement to turn this of. Default true
 * @return a Builder object.
 */
function mGenGenerate(registry, settings) {
    "use strict";
    settings = settings || {};
    settings = {
        warn: (typeof settings.warn === "undefined") ? true : settings.warn,
        never_catch_error: (typeof settings.never_catch_error === "undefined") ? false : settings.never_catch_error,
        validate: (typeof settings.validate === "undefined") ? true : settings.validate,
    };

    /**
     * The Builder is a class that can create a instances from the registry
     *
     * @class
     */
    var Builder = function() {};

    /**
     * Validate
     * call this method on a instance to type-validate it.
     * @param options {object} settings for this individual object (if not specified it inherits the settings from the call to mGenGenerate)
     * @return {bool} true if all fields correspond to class registry, false otherwise.
     */
    Builder.validate = function(object, options) {
        options = options || {};
        var def = {
            warn: false,
            validate: true
        };
        extend(options, def);
        extend(options, settings);

        try {
            new(Builder.getClass(registry.lookup(object.__t)))(object, options);
        } catch (e) {
            if (options.warn) {
                window.console.warn("Validation failed. Reason: \n" + e);
            }
            if (options.never_catch_error) {
                throw e;
            }
            return false;
        }
        return true;
    };

    /**
     * @param typeId {string} base64 hash for the class
     * @return {bool} true if the class exist in the builder, false otherwise.
     */
    Builder.hasClassWithId = function(typeId) {
        return registry.lookup(typeId) !== undefined;
    };

    /**
     * @param typeId {string} base64 hash for the class
     * @return {constructor} returns a class constructor for the specified typeid.
     */
    Builder.getClassWithId = function(typeId) {
        return Builder.getClass(registry.lookup(typeId));
    };

    /**
     * @param type path {string} the complete type path (or shorthand version) for the class, i.e "module1.module2.ClassName" or "ClassName"
     * @return {bool} true if the class exist in the builder, false otherwise.
     */
    Builder.hasClass = function(path) {
        return registry.classRegistry[path] !== undefined || typeof Builder[path] !== undefined;
    };

    /**
     * @param type path {string} the complete type path for the class, i.e "module1.module2.ClassName"
     * @return {constructor} returns a class constructor for the specified typeid.
     */
    Builder.getClass = function(path) {
        return treeIndexGet(Builder, path);
    };

    // create the classes in root and at absolue path.
    for (var obj_key in registry.classRegistry) {
        if (registry.classRegistry.hasOwnProperty(obj_key)) {
            registerClass(registry.classRegistry[obj_key], obj_key);
        }
    }

    var obj;
    //lets find each super and create inheritance
    for (obj in registry.classRegistry) {
        setParent(obj);
    }

    // The shorthand notation can create conflicts. Lets make sure we mark them as such.
    for (obj in registry.classRegistry) {
        if (registry.classRegistry.hasOwnProperty(obj_key)) {
            handleConflict(obj_key);
        }
    }
    obj = undefined;

    /* CREATION HELPER FUNCTIONS */

    function setParent(obj) {
        if (registry.classRegistry.hasOwnProperty(obj)) {
            var C = Builder.getClass(registry.lookup(registry.classRegistry[obj].__t));
            if (C.prototype instanceof Builder) {
                return;
            }
            var super_path = getParentTypePath(registry.classRegistry[obj]);
            if (!super_path) {
                C.prototype = new Builder();
            } else {
                setParent(super_path);
                C.prototype = new(Builder.getClass(super_path))("NO_CONSTRUCT");
            }
            C.prototype.constructor = C;
        }
    }

    function handleConflict(path) {
        var shortName = getShortName(path);
        var obj = Builder[shortName];
        if (Array.isArray(obj)) { // its a conflict
            Builder[shortName] = createConflictConstructor(obj);
        }
    }

    function createConflictConstructor(arr) {
        return function() {
            var e = "Call to conflicting constructor, please use full path istead of shorthand notation. \n";
            e = e + "Possible versions are: \n";
            for (var classPath in arr) {
                e = e + "\t" + classPath + "\n";
            }
            throw e;
        };
    }

    function getShortName(path) {
        var a = path.split(".");
        return a[a.length - 1];
    }

    function treeIndexGet(obj, path) {
        var original_path = path;

        function recTreeIndexGet(obj, path) {
            if (typeof path === "string") {
                return recTreeIndexGet(obj, path.split("."));
            } else if (path.length === 0 || obj[path[0]] === undefined) {
                if (typeof obj !== "function") {
                    throw "Class " + original_path + " not found in registry.";
                }
                return obj;
            } else {
                return recTreeIndexGet(obj[path[0]], path.slice(1));
            }
        }
        return recTreeIndexGet(obj, path);
    }

    function treeIndexSet(obj, path, value) {
        if (typeof path === "string") {
            treeIndexSet(obj, path.split("."), value);
        } else if (path.length === 1) {
            obj[path[0]] = value;
        } else {
            obj[path[0]] = obj[path[0]] || {};
            treeIndexSet(obj[path[0]], path.slice(1), value);
        }
    }

    function registerClass(obj, path) {
        var ClassConstructor = createClass(obj);
        treeIndexSet(Builder, path, ClassConstructor);
        if (!Builder[getShortName(path)]) {
            Builder[getShortName(path)] = ClassConstructor;
        } else {
            // we have a collision. Lets create a list of all the collisions and then later turn it into a warning for the user.

            var currentClassType = (new ClassConstructor("NO_CONSTRUCT")).__t;
            var currentClassPath = registry.lookup(currentClassType);

            if (typeof Builder[getShortName(path)] === "function") {
                var collidingClassType = (new Builder[getShortName(path)]("NO_CONSTRUCT")).__t;
                var collidingClassPath = registry.lookup(collidingClassType.__t);
                
                Builder[getShortName(path)] = [collidingClassPath, currentClassPath];
            } else {
                // append to collision list
                Builder[getShortName(path)].push(currentClassPath);
            }
        }
    }

    function createClass(obj) {
        return function(data, options) {
            if (data === "NO_CONSTRUCT") {
                this.__t = obj.__t;
                return;
            }

            var default_construction = false;
            if (data === "DEFAULT") {
                default_construction = true;
                data = null;
            }

            /* Options are local settings. Inherits from the settings done when created the registry */
            options = options || {};
            extend(options, settings);

            if (data) {
                if (data.__t) {
                    var objTypeHash = obj.__t;
                    var dataTypeHash = data.__t;

                    //If the data does not fit the corresponding type then check if it is a derived type.
                    if (objTypeHash != dataTypeHash) {
                        if (isDerivedType(data.__t, objTypeHash)) {
                            return new(Builder.getClass(registry.hashRegistry[dataTypeHash]))(data);
                        } else {
                            throw " Tried to create " + registry.hashRegistry[objTypeHash] + " but got " + registry.hashRegistry[dataTypeHash];
                        }
                    }
                }
                if (options.validate) {
                    //check for faulty indata.
                    for (var _key in data) {

                        if (!data.hasOwnProperty(_key)) continue;

                        if (!obj[_key] && _key != "__t") {
                            var possible = "";
                            for (var pos in obj) {
                                if (pos != "__t") possible += " \t " + pos + " \n ";
                            }
                            throw registry.lookup(obj.__t) + " does not have field " + _key +
                                " \n Possible options are: \n" + possible + " \n ";
                        }
                    }
                }
            }

            //populate fields with data.
            for (var field in obj) {
                if (!obj.hasOwnProperty(field)) continue;

                if (field === "__t") {
                    this.__t = obj.__t;
                } else {
                    try {
                        if (options.validate && !default_construction) {
                            this[field] = createField(obj[field], field, data, options);
                        } else if (default_construction) {
                            this[field] = createDefaultField(obj[field], field, options);
                        } else {
                            this[field] = data ? data[field] : null;
                        }
                    } catch (err) {
                        if (options.never_catch_error) {
                            throw err;
                        } else {
                            throw "Could not create object " + registry.lookup(obj.__t) + " Reason: \n" + err;
                        }
                    }
                    if (this[field] === null) {
                        delete(this[field]);
                    }
                }
            }
        };
    }

    function createField(field, key, data, options) {
        if (hasFlag(field.flags, "required")) {
            if (!data || !data[key]) {
                throw "Missing REQUIRED value: \"" + key + "\" of type " + field.type;
            }
            return createFieldOfType(field.type, data[key], options);
        } else {
            if (data && typeof data[key] !== "undefined") {
                return createFieldOfType(field.type, data && data[key] || null, options);
            } else {
                return null;
            }
        }
    }

    function createDefaultField(field, key, options) {
        if (options.validate && hasFlag(field.flags, "required")) {
            throw "Missing REQUIRED value: \"" + key + "\" of type " + field.type;
        } else {
            return createFieldOfType(field.type, null, options);
        }
    }


    /**
     * @param type {string} - is a base type (int64 etc.) or a complex base type ( map:int32:math.Vector3 ) or a class path ( math.Vector3 ) or a class hash.
     */
    function createFieldOfType(type, value, options) {
        var classFound, baseType, t = type.split(":");

        //if we got an hash as type
        classFound = registry.lookup(t[0]);
        if (classFound) {
            t[1] = classFound;
            baseType = "object";
        }

        //if we got a complete path as type
        classFound = registry.classRegistry[t[0]];
        if (classFound) {
            t[1] = classFound;
            baseType = "object";
        }

        if (classFound === undefined) {
            baseType = t[0];
        }

        var C, ret;
        switch (baseType) {
            case "object":
                if (value && typeof value !== "object") {
                    throw "Tried to create " + type + " but had no object data.";
                }
                value = value || {};
                ret = new(Builder.getClass(t[1]))(value);
                return ret;
            case "list":
                if (value && !Array.isArray(value)) {
                    throw "Tried to create " + type + " but had no array data.";
                }
                value = value || [];
                ret = [];
                C = Builder.getClass(t[1]);
                value.forEach(function(entry) {
                    ret.push(new C(entry));
                });
                return ret;
            case "map":
                if (value && typeof value !== "object") {
                    throw "Tried to create " + type + " but had no object data.";
                }
                value = value || {};
                ret = {};
                for (var key in value) {
                    if (value.hasOwnProperty(key)) {
                        ret[createFieldOfType(t[1], key, options)] = createFieldOfType(t[2], value[key], options);
                    }
                }
                return ret;
            case "int8":
                checkInt(value, 8, type, options);
                ret = value || 0;
                return ret;
            case "int16":
                checkInt(value, 16, type, options);
                ret = value || 0;
                return ret;
            case "int32":
                checkInt(value, 32, type, options);
                ret = value || 0;
                return ret;
            case "int64":
                checkInt(value, 64, type, options);
                ret = value || 0;
                return ret;
            case "float32":
                checkFloat(value, 32, type, options);
                ret = value || 0;
                return ret;
            case "float64":
                checkFloat(value, 64, type, options);
                ret = value || 0;
                return ret;
            case "string":
                if (value && typeof value !== "string") {
                    throw "Tried to create " + type + " but had no string data.";
                }
                ret = value || "";
                return ret;
        }
    }

    function checkInt(value, size, type, options) {
        if (size > 32) {
            if (options.warn) {
                window.console.warn("mgen_js cannot handle 64 bit integers well due to javascript limitations. See https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Int64");
            }
        }

        if (typeof value === "undefined" || value === null) {
            return;
        }

        if (typeof value !== "number") {
            throw "Tried to create " + type + " but data was of type: " + (typeof value);
        }

        if (isNumeric(parseInt(value, 10)) && (parseFloat(value, 10) === parseInt(value, 10))) {
            var lim = Math.pow(2, size - 1);
            if (value > lim - 1 || value < -lim) {
                throw value + " is out of range for int" + size;
            }
            return true;
        } else {
            throw "Tried to create " + type + " but data ( " + value + " ) was not a valid integer.";
        }
    }

    function checkFloat(value, size, type) {
        if (typeof value === "undefined" || value === null) {
            return;
        }
        if (!isNumeric(value)) {
            throw "Tried to create " + type + " but data ( " + value + " ) was not a valid float.";
        }
    }

    function hasFlag(fields, flag) {
        return (fields.indexOf(flag) > -1);
    }

    function isNumeric(number) {
        // Borrowed from jQuery with comment:
        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        return number - parseFloat(number) >= 0;
    }

    function getTypePath(obj) {
        return registry.lookup(obj.__t);
    }

    /**
     * @param derived {string} hash from derived type
     * @param base {string} hash from base type
     */
    function isDerivedType(derived, base) {
        return derived.substr(0, base.length - 1) === base;
    }

    function getParentTypePath(obj) {
        var parentHash = obj.__t.slice(0, -3);
        if (parentHash.length > 0) {
            return registry.lookup(parentHash);
        } else {
            return null;
        }
    }

    function extend(options, settings) {
        for (var field in settings) {
            if (!settings.hasOwnProperty(field)) continue;
            options[field] = (typeof options[field] === "undefined") ? settings[field] : options[field];
        }
    }

    return Builder;
}