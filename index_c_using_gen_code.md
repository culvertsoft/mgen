---
layout: default
link-title: Using generated code
submenu:
  - { anchor: "a", target-tab: "cpp-example", title: "cpp example" }
  - { anchor: "a", target-tab: "java-example", title: "java example" }
  - { anchor: "a", target-tab: "javascript-example", title: "javascript example" }
  - { anchor: "d", title: "other wire formats" }
  - { anchor: "e", title: "limitations" }
---

## Using generated code

This page shows how to serialize objects of [previously generated example classes](index_c_Generating_code.html). 

<div class="tabs"><a name="a">&nbsp;</a> 
  <ul>
      <li>
          <a tab-id="cpp-example" href="{{ site.baseurl }}/using_gen_code_tabs/cpp_example_1.html">C++ example</a>
      </li>
      <li>
          <a tab-id="java-example" href="{{ site.baseurl }}/using_gen_code_tabs/java_example_1.html">Java example</a>
      </li>
      <li>
          <a tab-id="javascript-example" href="{{ site.baseurl }}/using_gen_code_tabs/javascript_example_1.html">Javascript example</a>
      </li>
  </ul>
</div>

### Other wire formats <a name="d">&nbsp;</a>

MGen supports both binary and JSON serialization formats out-of-the-box. You can also use generic converters between other formats (e.g. XML, YAML) and JSON to map data written in those formats directly to MGen objects.

If you wish to go further you can also add completely custom formats by creating your own reader and writer classes, which are just generic object visitors.


### Limitations <a name="e">&nbsp;</a>

MGen serializers are designed to be state-less. There is no common object graph preservation or node-to-node implementation with synchronization. This is a conscious design choice and also implies that the standard implementation of serializers do not support circular references. 

MGen serializers consider all data to be just that - data. They have no concept of references or object identities (Although generated polymorphic code and data types in most languages are of reference types - during serialization they are treated as nothing more than polymorphic data containers).

These limitations bring with them some benefits. It allows us to support lossy and reordering protocols without worrying about objects having all the necessary information to be reconstructed on receiving side. If you wish to send one message over http, another over a UDP socket and a third with smoke signals, in the opposite order, MGen won't really care.

We believe identities and true object graphs should be the responsibility of the layer above - the layer syncronizing applications with each other - not the fundamental data serialization layer. We have plans to build such systems as future products - but not as a part of MGen.

In short - we chose to separate the concerns of data representation from data identity and transport method - the two latter not being anything MGen is concerned with at this point.

However, you can add your own object identity and graph synchronization system using classes generated by MGen (Something we already did for our visual data model editor).



